import express from 'express';
import mongoose from 'mongoose';
import Booking from '../models/booking.model.js';
import User from '../models/user.model.js'; // Assuming you might need User model for some checks
import jwt from 'jsonwebtoken'; // For authentication

const router = express.Router();

// Temporary in-memory storage for bookings (replace with MongoDB model later)
let bookings = [];

// Middleware to authenticate and get user ID
const authenticate = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is required.' });
  }
  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (err) {
    console.error("Authentication error:", err);
    return res.status(401).json({ message: 'Invalid or expired token.' });
  }
};

// Store a booking from payment verification
router.post('/store', async (req, res) => {
  try {
    const booking = {
      ...req.body,
      createdAt: new Date()
    };
    bookings.push(booking);
    res.status(201).json({ success: true, booking });
  } catch (err) {
    res.status(500).json({ error: 'Failed to store booking' });
  }
});

// Get all bookings
router.get('/', async (req, res) => {
  try {
    const userBookings = bookings.filter(booking => booking.userId === req.user.userId);
    res.json({ bookings: userBookings });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch bookings' });
  }
});

// POST /api/bookings/initiate - Initiate a booking (before payment)
router.post('/initiate', authenticate, async (req, res) => {
  try {
    const { trainDetails, passengers, totalFare, paymentGateway = 'Razorpay' } = req.body;

    // Basic validation
    if (!trainDetails || !passengers || !totalFare) {
      return res.status(400).json({ message: 'Missing required booking information.' });
    }

    // Create a temporary booking with PENDING_PAYMENT status
    const newBooking = new Booking({
      userId: req.userId,
      trainDetails,
      passengers,
      totalFare,
      paymentDetails: {
        transactionId: `TEMP_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,
        paymentGateway,
        amount: totalFare,
        status: 'PENDING'
      },
      status: 'PENDING_PAYMENT'
    });

    await newBooking.save();
    
    res.status(201).json({ 
      message: 'Booking initiated successfully!',
      bookingId: newBooking._id,
      booking: newBooking,
      paymentRequired: true
    });

  } catch (error) {
    console.error('Error initiating booking:', error);
    res.status(500).json({ message: 'Failed to initiate booking. Please try again later.' });
  }
});

// POST /api/bookings/confirm-payment - Confirm payment and finalize booking
router.post('/confirm-payment', authenticate, async (req, res) => {
  try {
    const { bookingId, transactionId, paymentStatus, paymentGateway } = req.body;

    if (!bookingId || !transactionId) {
      return res.status(400).json({ message: 'Missing booking ID or transaction ID.' });
    }

    const booking = await Booking.findOne({ _id: bookingId, userId: req.userId });
    if (!booking) {
      return res.status(404).json({ message: 'Booking not found.' });
    }

    // Update payment details
    booking.paymentDetails.transactionId = transactionId;
    booking.paymentDetails.status = paymentStatus === 'success' ? 'SUCCESSFUL' : 'FAILED';
    booking.paymentDetails.paymentDate = new Date();
    if (paymentGateway) booking.paymentDetails.paymentGateway = paymentGateway;

    // Update booking status based on payment
    if (paymentStatus === 'success') {
      booking.status = 'CONFIRMED';
      // PNR will be auto-generated by the pre-save hook
    } else {
      booking.status = 'CANCELLED';
    }

    await booking.save();
    
    res.status(200).json({ 
      message: paymentStatus === 'success' ? 'Payment confirmed! Booking successful.' : 'Payment failed. Booking cancelled.',
      booking,
      success: paymentStatus === 'success'
    });

  } catch (error) {
    console.error('Error confirming payment:', error);
    res.status(500).json({ message: 'Failed to confirm payment. Please try again later.' });
  }
});

// POST /api/bookings/webhook - Payment gateway webhook endpoint
router.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  try {
    console.log('Webhook received:', req.body);
    
    // Parse the webhook payload (this will vary based on your payment gateway)
    const webhookData = req.body;
    
    // Example webhook structure (adjust based on your payment gateway)
    const { transaction_id, booking_id, status, amount, gateway } = webhookData;
    
    if (!transaction_id || !booking_id) {
      return res.status(400).json({ message: 'Invalid webhook data' });
    }

    const booking = await Booking.findById(booking_id);
    if (!booking) {
      console.log(`Booking not found for webhook: ${booking_id}`);
      return res.status(404).json({ message: 'Booking not found' });
    }

    // Update payment status based on webhook
    booking.paymentDetails.transactionId = transaction_id;
    booking.paymentDetails.status = status === 'success' ? 'SUCCESSFUL' : 'FAILED';
    booking.paymentDetails.paymentDate = new Date();
    if (gateway) booking.paymentDetails.paymentGateway = gateway;

    if (status === 'success') {
      booking.status = 'CONFIRMED';
    } else {
      booking.status = 'CANCELLED';
    }

    await booking.save();
    
    console.log(`Booking ${booking_id} updated via webhook: ${status}`);
    res.status(200).json({ message: 'Webhook processed successfully' });

  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).json({ message: 'Webhook processing failed' });
  }
});

// POST /api/bookings - Create a new booking (legacy endpoint for backward compatibility)
router.post('/', authenticate, async (req, res) => {
  try {
    const { trainDetails, passengers, totalFare, paymentDetails } = req.body;

    // Basic validation
    if (!trainDetails || !passengers || !totalFare || !paymentDetails || !paymentDetails.transactionId) {
      return res.status(400).json({ message: 'Missing required booking information.' });
    }

    // Ensure payment was successful before confirming booking
    if (paymentDetails.status !== 'SUCCESSFUL') {
        return res.status(400).json({ message: 'Payment was not successful. Booking cannot be confirmed.' });
    }

    const newBooking = new Booking({
      userId: req.userId,
      trainDetails,
      passengers,
      totalFare,
      paymentDetails,
      status: 'CONFIRMED',
    });

    await newBooking.save();
    
    res.status(201).json({ 
        message: 'Booking created successfully!',
        booking: newBooking 
    });

  } catch (error) {
    console.error('Error creating booking:', error);
    if (error.code === 11000) {
        return res.status(409).json({ message: 'Duplicate transaction ID. This booking might already exist.' });
    }
    if (error.name === 'ValidationError') {
        return res.status(400).json({ message: 'Validation Error', details: error.errors });
    }
    res.status(500).json({ message: 'Failed to create booking. Please try again later.' });
  }
});

// GET /api/bookings/my-bookings - Get bookings for the logged-in user with filters
router.get('/my-bookings', authenticate, async (req, res) => {
  try {
    const { status, page = 1, limit = 10, sortBy = 'bookingDate', sortOrder = 'desc' } = req.query;
    
    // Build filter query
    const filter = { userId: req.userId };
    if (status) {
      filter.status = status;
    }

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Build sort object
    const sort = {};
    sort[sortBy] = sortOrder === 'asc' ? 1 : -1;

    const bookings = await Booking.find(filter)
                                  .sort(sort)
                                  .skip(skip)
                                  .limit(parseInt(limit))
                                  .populate('userId', 'name email');

    const totalBookings = await Booking.countDocuments(filter);
    const totalPages = Math.ceil(totalBookings / parseInt(limit));

    // Get booking statistics
    const stats = await Booking.aggregate([
      { $match: { userId: new mongoose.Types.ObjectId(req.userId) } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalAmount: { $sum: '$totalFare' }
        }
      }
    ]);

    res.status(200).json({
      bookings,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalBookings,
        hasMore: parseInt(page) < totalPages
      },
      stats: stats.reduce((acc, stat) => {
        acc[stat._id] = { count: stat.count, totalAmount: stat.totalAmount };
        return acc;
      }, {})
    });
  } catch (error) {
    console.error('Error fetching user bookings:', error);
    res.status(500).json({ message: 'Failed to retrieve your bookings. Please try again later.' });
  }
});

// GET /api/bookings/:bookingId - Get a specific booking by its ID
router.get('/:bookingId', authenticate, async (req, res) => {
    try {
        const { bookingId } = req.params;
        if (!mongoose.Types.ObjectId.isValid(bookingId)) {
            return res.status(400).json({ message: 'Invalid booking ID format.' });
        }

        const booking = await Booking.findOne({ _id: bookingId, userId: req.userId })
                                    .populate('userId', 'name email phone');

        if (!booking) {
            return res.status(404).json({ message: 'Booking not found or you do not have permission to view it.' });
        }

        res.status(200).json(booking);
    } catch (error) {
        console.error('Error fetching booking by ID:', error);
        res.status(500).json({ message: 'Failed to retrieve the booking. Please try again later.' });
    }
});

// POST /api/bookings/:bookingId/cancel - Cancel a booking
router.post('/:bookingId/cancel', authenticate, async (req, res) => {
  try {
    const { bookingId } = req.params;
    const { reason } = req.body;

    if (!mongoose.Types.ObjectId.isValid(bookingId)) {
      return res.status(400).json({ message: 'Invalid booking ID format.' });
    }

    const booking = await Booking.findOne({ _id: bookingId, userId: req.userId });
    
    if (!booking) {
      return res.status(404).json({ message: 'Booking not found.' });
    }
    
    if (booking.status === 'CANCELLED') {
      return res.status(400).json({ message: 'Booking is already cancelled.' });
    }

    if (booking.status === 'COMPLETED') {
      return res.status(400).json({ message: 'Cannot cancel a completed journey.' });
    }
    
    booking.status = 'CANCELLED';
    booking.cancellationReason = reason || 'Cancelled by user';
    booking.cancellationDate = new Date();
    
    await booking.save();
    
    res.json({ 
      message: 'Booking cancelled successfully',
      booking 
    });
  } catch (error) {
    console.error('Error cancelling booking:', error);
    res.status(500).json({ message: 'Failed to cancel booking. Please try again later.' });
  }
});

// GET /api/bookings/statistics - Get user booking statistics
router.get('/statistics/summary', authenticate, async (req, res) => {
  try {
    const stats = await Booking.aggregate([
      { $match: { userId: new mongoose.Types.ObjectId(req.userId) } },
      {
        $group: {
          _id: null,
          totalBookings: { $sum: 1 },
          totalAmount: { $sum: '$totalFare' },
          confirmedBookings: {
            $sum: { $cond: [{ $eq: ['$status', 'CONFIRMED'] }, 1, 0] }
          },
          cancelledBookings: {
            $sum: { $cond: [{ $eq: ['$status', 'CANCELLED'] }, 1, 0] }
          },
          completedBookings: {
            $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] }
          }
        }
      }
    ]);

    res.json(stats[0] || {
      totalBookings: 0,
      totalAmount: 0,
      confirmedBookings: 0,
      cancelledBookings: 0,
      completedBookings: 0
    });
  } catch (error) {
    console.error('Error fetching booking statistics:', error);
    res.status(500).json({ message: 'Failed to fetch statistics.' });
  }
});

export default router; 